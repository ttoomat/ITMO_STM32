/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "initialization.h"

// transmit an array
void transmit(const uint8_t* data, uint8_t n) {
  for (uint8_t i = 0; i < n; i++) {
	// пока TXE = 0 будет задержка (TXE = 1 means USART_DR is empty, we can write)
    while (!(USART2->SR & USART_SR_TXE)) {};
	USART2->DR = data[i];
  }
}

// обработчик операции которая по вариантам
void variant_handler(const uint8_t* data, uint8_t n) {
	// выключим все светодиоды:
	GPIOC->ODR &= 0xF00F;
	switch(data[1]) {
	case '0': {
		//transmit(off0, n_trans);
		break;
	}
	case '1': {
		//transmit(led1, n_trans);
		// pc4
		GPIOC->ODR |= (1U << 4);
		break;
	}
	case '2': {
		GPIOC->ODR |= (1U << 5);
		break;
	}
	case '3': {
		GPIOC->ODR |= (1U << 6);
		break;
	}
	case '4': {
		GPIOC->ODR |= (1U << 7);
		break;
	}
	case '5': {
		GPIOC->ODR |= (1U << 8);
		break;
	}
	case '6': {
		GPIOC->ODR |= (1U << 9);
		break;
	}
	case '7': {
		GPIOC->ODR |= (1U << 10);
		break;
	}
	case '8': {
		GPIOC->ODR |= (1U << 11);
		break;
	}
	}
}

void command_handler(const uint8_t* data, uint8_t n) {
	// command
	switch (data[0]) {
	// echo - repeat command
	case 'e' | 'E': {
		transmit(data, n);
		break;
	}
	// all leds on PC4-PC11
	case 'a' | 'A': {
		GPIOC->ODR |= 0x0FF0;
		transmit(data, n);
		break;
	}
	// all leds off
	case 'f' | 'F': {
		GPIOC->ODR &= ~0xFF0;
		transmit(data, n);
		break;
	}
	// variant command: accept '0'-'8' number and turn on one led
	case 'v' | 'V': {
		variant_handler(data, n);
		transmit(data, n);
		break;
	}
	// show leds configuration like 0b00010010
	case 's' | 'S': {
		// можно просто считать ODR
		uint32_t leds = GPIOC->ODR;
		leds &= 0x0FF0;
		uint8_t res[8];
		for (uint8_t i = 4; i < 12; i++) {
			if (leds & (1U << i))
				res[i-4]='1';
			else res[i-4]='0';
		}
		transmit(res, 8);
		break;
	}
	}
}

uint8_t counter=0;
// массив считанных данных
uint8_t buf[] = {'a', 'b', 'c', 'd'};
// Каждый байт массива снова вызывает эту функцию
// здесь происходит считывание входных данных
void USART2_IRQHandler() {
	uint8_t n = 4;
	// receive
	if (USART2->SR & USART_SR_RXNE) {
		buf[counter] = (uint8_t)(USART2->DR & 0xFF);
		// снять RXNE
		USART2->SR &= ~USART_SR_RXNE_Msk;
		counter += 1; // считали ещё один бит
	}
	// если считаны все данные, их пора обработать
	if (counter >= n) {
		command_handler(buf, n);
		counter=0;
	}
}

int main(void) {
  GPIOA_Init();
  USART2_Init();
  LED_mode_setup();

  // loop forever
  for(;;) {
  }
}
