/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f446xx.h"

#define BAUDRATE 19200
#define APBx_FREQ 16000000
#define GPIOAEN				   (1U << 0)
#define GPIOCEN                (1U << 2)

void USART2_Init() {
  // тактирование
  RCC->APB1ENR |= RCC_APB1ENR_USART2EN;

  //a) Включите приёмник и передатчик.
  // transmit enable, receive enable
  USART2->CR1 |= USART_CR1_TE;
  USART2->CR1 |= USART_CR1_RE;
  //b) Рассчитайте и установите скорость передачи (baud rate) в регистре (USART_BRR)
  // для системной частоты 16MHz
  USART2->BRR = APBx_FREQ / BAUDRATE;
  //c) Включите генерацию прерываний RXNE (USART_SR)
  USART2->SR = USART_SR_RXNE;
  //d) Разрешите соответствующий вектор прерываний USART в NVIC. - ?
  // указать функцию прерываний
  NVIC_EnableIRQ(USART2_IRQn);
  //e) Включите сам USART (USART_CR1, UE=1 ?)
  USART2->CR1 |= USART_CR1_UE;
}

void GPIOA_Init() {
  // тактирование
  RCC->AHB1ENR |= GPIOAEN;

  // PA2 mode: AF (10)
  GPIOA->MODER |= (1U << 5);
  GPIOA->MODER &= ~(1U << 4);
  // PA3 mode: AF (10)
  GPIOA->MODER |= (1U << 7);
  GPIOA->MODER &= ~(1U << 6);

  // PA2 AFRL=AFR[0] 0111: AF07 (USART2_TX)
  GPIOA->AFR[0] &= ~(1U << 11);
  GPIOA->AFR[0] |= (1U << 10);
  GPIOA->AFR[0] |= (1U << 9);
  GPIOA->AFR[0] |= (1U << 8);

  // PA3 AF: AF07 (0111) (USART2_RX)
  GPIOA->AFR[0] &= ~(1U << 15);
  GPIOA->AFR[0] |= (1U << 14);
  GPIOA->AFR[0] |= (1U << 13);
  GPIOA->AFR[0] |= (1U << 12);
}

void LED_mode_setup() {
  RCC->AHB1ENR |= GPIOCEN;
  // 8 leds
  // moder for pc4 = 01 - output mode
  GPIOC->MODER |= (1U << 8);
  GPIOC->MODER &= ~(1U << 9);
  // pc5 output
  GPIOC->MODER |= (1U << 10);
  GPIOC->MODER &= ~(1U << 11);
  // pc6 output
  GPIOC->MODER |= (1U << 12);
  GPIOC->MODER &= ~(1U << 13);
  // pc7 output
  GPIOC->MODER |= (1U << 14);
  GPIOC->MODER &= ~(1U << 15);
  // pc8 output
  GPIOC->MODER |= (1U << 16);
  GPIOC->MODER &= ~(1U << 17);
  // pc9 output
  GPIOC->MODER |= (1U << 18);
  GPIOC->MODER &= ~(1U << 19);
  // pc10 output
  GPIOC->MODER |= (1U << 20);
  GPIOC->MODER &= ~(1U << 21);
  // pc11 output
  GPIOC->MODER |= (1U << 22);
  GPIOC->MODER &= ~(1U << 23);
  // button
  // pd2, pc13 - input = 00 - reset state
}

// transmit an array
void transmit(uint8_t * data, uint8_t n) {
  for (uint8_t i = 0; i < n; i++) {
	// пока TXE = 0 будет задержка (TXE = 1 means USART_DR is empty, we can write)
    while (!(USART2->SR & USART_SR_TXE)) {};
	USART2->DR = data[i];
  }
}

// обработчик операции которая по вариантам
void handler(uint8_t * data, uint8_t n) {
	/* Сейчас обработчик посылает текстовый ответ.
	 * В лабе обработчик будет включать светодиод.
	 */
	uint8_t led1[] = {'l', 'e', 'd', '\r', '\n'};
	uint8_t off0[] = {'o', 'f', 'f', '\r', '\n'};
	uint8_t n_trans = 5;
	switch(data[1]) {
	case '1': {
		transmit(led1, n_trans);
		break;
	}
	case '0': {
		transmit(off0, n_trans);
		break;
	}
	}
}

uint8_t receive() {
	uint8_t res;
	while (!(USART2->SR & USART_SR_RXNE)) {};
	res = USART2->DR;
	// сброс флага RXN
	USART2->SR &= ~USART_SR_RXNE;
	return res;
}

uint8_t* receive_arr(uint8_t n) {
	uint8_t arr[] = {'a', 'b', 'c', 'd'};
	uint8_t *t = arr;
	// receive
	// when character is received, RXNE bit is set
	// while nothing is received -- wait
	for (uint8_t i = 0; i < n; i++) {
		t[i] = receive();
	}
	return t;
}

int main(void) {
  GPIOA_Init();
  USART2_Init();
  LED_mode_setup();

  // repeater
  // variable to store received data

  uint8_t n = 4;
  uint8_t t[] = {'a', 'b', 'c', 'd'};
  uint8_t *ptr;
  // loop forever
  for(;;) {
	  ptr = receive_arr(n);
	  for (uint8_t i = 0; i < n; i++) {
		  t[i] = ptr[i];
	  }
	// получили данные -- пора отправить ответ
	handler(t, n);
  }
}
